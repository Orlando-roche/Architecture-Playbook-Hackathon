:moduledir: ..
include::{moduledir}/../ROOT/partials/_commons.adoc[]

= Authentication
:page-content-owner-email: christian.blumenroehr@roche.com

IMPORTANT: This article is still a work in progress and will be updated to provide a holistic view of the CS CoE.

== Client Onboarding

IMPORTANT: The below steps describe the requesting flow. Onboarding is always done on Ping Federate QA (wamqa.roche.com) first. *However, the full client onboarding is only complete after onboarding to Ping Federate PRD (wam.roche.com)*

. General remarks
* https://docs.google.com/presentation/d/1LjrKy8sOVo9IRY8n8eTuezlXO_YHdLrcAGmDBOIzGts/edit#slide=id.g9a3813994d_1_24[Service Book^] - This book defines the service for SSO via PingFederate.

* We keep a list of all our PingFed clients used in pRED for better transparency. Therefore please add your client as well in https://docs.google.com/spreadsheets/d/1IQVFoi_OmRCxD-uJvy2oTVIFapBGwtvM_M-GULStdZ0/edit#gid=0[this gSheet^].
* We have a special https://chat.google.com/room/AAAAebrOyNY?cls=1[chat space^] with the IAM team in place to follow up on specific technical topics around our PingFed clients.
* To ensure interoperability of our applications all PingFed clients should use the *pRED standard token structure*.
* You might order different clientIDs for your different environments ("pred-myApplication-dev", "pred-myApplication-prod"). However, this is not a must. In fact all redirect URLs from all environments can be added to the same PingFed client.
* You need to have an entry for your application in https://roche.service-now.com/act[ACT^]. Please make sure to mark your application as using SSO and add "Ping Federate" as dependency in the tech profile:

image::Act.png[width=50%] 

[start=2]
. If you need a PingFed client for *standard authorization code flow*
* Follow the instructions in https://roche.service-now.com/rose?id=kb_article_view&table=kb_knowledge&sys_kb_id=539434fa87b2521800f232640cbb3542[this KB article^] and use the automated OAUTH integration by creating an iCare ticket using https://roche.service-now.com/icare?id=sc_cat_item&sys_id=ae42511487e1d2141f3c63560cbb357e[this form^].
* *Important*: Please select the "pRED standard Access Token" in the "Access Token Management OIDC Policy" 
+
image::Token-standard.png[width=50%]

* The redirect URL(s) are not (yet) included in the form and will need to be configured after the initial setup.
* Once the client has been tested on wamqa (PingFed QA), you can also use this form for propagating the client to wam (PingFed Prod) by selecting the corresponding value in "Task".

[start=3]
. If you need a PingFed client for *other authentication flows* (ROPC, Client Credentials, Device Authentication)
* You can still request a client via the above form and contact the IAM team to adjust it accordingly.
* Or you use the general iCare https://roche.service-now.com/rose?id=nr_sc_cat_item&sys_id=d92621871b4625d046bcdca19b4bcbf0[request form^] for “Web Access Control SSO/Federation/OAuth/OIDC Integration”.
** Access Token Manager Claims OR existing Access Token Manager Name: please do not specifiy individual claims but just write "*pRED standard token structure*"
** OpenID Connect Policy Claims OR existing OpenID Connect Policy: please do not specifiy individual claims but just write "*pRED standard token structure*"

After the iCare request has been processed, the following information will be provided:

* Client ID: E.g. "pred-myApplication"
* Client Secret: E.g. "[secret]"
* Issuer: E.g. `https://wamqa.roche.com`
* Auth endpoint: E.g. `https://wamqa.roche.com/as/authorization.oauth2`
* Token endpoint: E.g. `https://wamqa.roche.com/as/token.oauth2`
* JWKS endpoint: E.g. `https://wamqa.roche.com/pf/JWKS`

NOTE: The URLs mentioned above are also exposed via the api `https://wamqa.roche.com/.well-known/openid-configuration`

These details should be sufficient to get started and validate that the PingFederate authentication has been configured correctly.
The request URL should then be of the form:
`https://wamqa.roche.com/as/authorization.oauth2?client_id=pred-myApplication&response_type=code&scope=profile%20openid&redirect_uri=https%3A%2F%2Fdev.myapp.roche.com%2F`


=== Validation of a successful PingFed Client onboarding
Validation of the onboarded PingFederate client includes a few simple steps and can help to take a decision to move the client configuration into production.

1 . Download collections and import them into Postman.

a) For Auth Code clients:

- The link:{attachmentsdir}/PingFedEnvironmentTemplate.postman_environment.json[Postman Environment] needs to be configured by adding the clientId, clientSecret and redirectUrl for the onboarded client. Afterwards select the Environment from the drop-down menu in Postman on the top-right corner of the window.
- This link:{attachmentsdir}/PingFedTest.postman_collection.json[Postman Collection] will add two calls, one to the Userinfo endpoint and a second for Arvados. Please refer to the Documentation in the collection.

b) For ROPC clients:
 
- The link:{attachmentsdir}/PingFedEnvironmentTemplateROPC.postman_environment.json[Postman Environment] needs to be configured by adding the clientId, clientSecret and redirectUrl for the onboarded client and username, password for the authenticating user. Afterwards select the Environment from the drop-down menu in Postman on the top-right corner of the window.
- This link:{attachmentsdir}/PingFedTestROPC.postman_collection.json[Postman Collection] will add three calls, one to the Userinfo endpoint, a second for the ROPC endpoint and a third to refresh the token. 

c) For "Client Credentials" clients:
 
- The link:{attachmentsdir}/PingFedEnvironmentTemplate.postman_environment.json[Postman Environment] needs to be configured by adding the clientId, clientSecret and redirectUrl for the onboarded client and username, password for the authenticating user. Afterwards select the Environment from the drop-down menu in Postman on the top-right corner of the window.
- This link:{attachmentsdir}/PingFed_TestClientCredentials.postman_collection.json[Postman Collection] will add three calls, one to the Userinfo endpoint, a second for the Client Credentials endpoint and a third to refresh the token. 

2 . Get an Access token

Once the Enviroment is properly filled and selected, hit the `Get New Access Token` Button in the Auth Tab of the `Userinfo` request, enter the credentials and, on success, press the `Use Token` Button. This will fill the Authentication Header with a Bearer Access Token.

3 . Submit to the `Userinfo` endpoint of Ping
Hit the `Send` Button to submit the call to the `Userinfo`. The response will be a `JSON` containing the claims that have been configured for the ID token and should look like this.

[source,json]
----
{
  "sub": "Roche unix user ID",
  "aud": "{client_id}",
  "name": "Full Name",
  "given_name": "First Name",
  "family_name": "Last Name",
  "email": "first.last@roche|gene.com",
}
----

image::PostmanGetAccessToken.png[width=50%]

4 . ID and Access Token Structure

The token structures are defined in the section xref:guidelines:iam.adoc[token structure,window=_blank]. The token values obtained in the previous steps can be inspected on https://jwt.io[jwt.io]. Check that non of the claimes defined in the standard are missing in both your xref:guidelines:iam.adoc[id token,window=_blank] and xref:guidelines:iam.adoc[access token,window=_blank].

You can also decode a token with the following script to check its structure in executing <script name.sh> <token>:

[source,shell]
----
#!/bin/bash

for part in 1 2; do
  b64="$(cut -f$part -d. <<< "$1" | tr '_-' '/+')"
  len=${#b64}
  n=$((len % 4))
  if [[ 2 -eq n ]]; then
    b64="${b64}=="
  elif [[ 3 -eq n ]]; then
    b64="${b64}="
  fi
  d="$(openssl enc -base64 -d -A <<< "$b64")"
  python -mjson.tool <<< "$d"
  # don't decode further if this is an encrypted JWT (JWE)
  if [[ 1 -eq part ]] && grep '"enc":' <<< "$d" >/dev/null ; then
      exit 0
  fi
done
----

== Environment Mapping for OIDC Clients

Onboarding of new PingFed clients starts on PingFed QA (wamqa.roche.com), then continues with PingFed UA (wamua.roche.com) to finally reach PingFed PROD (wam.roche.com). Since PingFed PROD is a GxP environment this process must be followed but theoretically can be done in 1-2 weeks.

IMPORTANT: To ensure proper interoperability of all applications using PingFed it is important that all applications are using PingFed PROD on all their environments, i.e. DEV, QA, TEST, PREPROD, PROD.

PingFed QA and UA should only be used in the initial onboarding or when changes on the PingFed side require testing against a dedicated PingFed environment.

IMPORTANT: A PROD client should be configured to accept redirect URLs for all the environments of the application. This way a single PingFed PROD client can be used for all environments of a particular application.

NOTE: The same signing certificate is used for all PingFed environments. Therefore you can validate a token from wamqa with the JWKS URL from wam (as it is done on Gravitee).
However, if you use the userinfo endpoint (https://wam.roche.com/idp/userinfo.openid) to validate the token and to retrieve additional user information, then the issuer must be the same (see also <<Token Validation>>).

== Token Propagation Between Applications and Systems

The strength of a common standard of Token Structures (see xref:guidelines:iam.adoc[OIDC & OAUTH Token Guidelines,window=_blank]) is the ability to implement seamless integration on API level in a secure way. This eliminates the need to build complex and insecure workarounds to integrate systems with different security architectures.

The diagram below illustrates the idea how systems can integrate with each other.

:figure-caption!:
image::authentication_flowchart.png[title="Illustration of SSO flows and Access Token Flows"]

*Example Token Propagation Flow*

. The Application "Pathomation" (Pathology Image Viewer) is a PingFederate client based on our pRED token standard structure. Users of Pathomation authenticate when opening the App and PingFed generates a pair of `ID Token` and `Access Token` using the SSO flow `Authorization Code Grant Type`
. When Users are opening an Image (Images are managed and stored in Arvados), Pathomation is passing the `Access Token` to the Arvados S3 API. Arvados is validating the tokens and the permissions of the user and serve the requested data (see <<Token Validation>> for more details).

== Integrating oAuth2/OIDC with PingFederate into APIs

The Basis for a successful integration of systems using PingFederate issues `Access Tokens` is:

. The standardized token structure
. How tokens are passed between systems via APIs
. How tokens are validated by the receiving API

=== Token Forwarding

oAuth2 Access Tokens must be passed to the API clients as "Bearer" Tokens. The clients calling the APIs are bearers of the identity of a user for the request made. Users delegate the handling of their identity to the client.

The standard way of submitting Access Tokens is via the `Authorization` header. This is the default and should ab assumed by every API implementation as well as by every API integration.

.Request Header for Token Forwarding
----
Authorization: Bearer <Access Token>

e.g.
Authorization: Bearer eyJhxxx.eyJzY29wZSI6Inxxx.t6qT8fRw5noxxx
----

IMPORTANT: APIs can decide to read the Token from a different Header. This should be avoided or clearly documented.

=== Token Validation
IMPORTANT: *Tokens must always be validated*. Access Tokens are issued as JWTs (see https://jwt.io[jwt.io] for details), these JWTs can be decoded and interpreted easily. However the payload of a JWT can also be changed as easily (e.g. changing the expiration date or the user ID). Therefore proper validation is required.

The basics of token validation start with the assumption that tokens are consumed by a different client than the client a token was issued to. In the simple scenario shown in the figure below there are three parties:

. Ping Federate (IDP = Identity Provider) - Issuing and Validating Tokens
. Application A - The Application which obtains the tokens through a SSO flow
. API Application B - An API which accepts Access Tokens as authentication

image::token_validation_basic.png[title="Token Request and Verification Flow"]

The API in Application B *MUST* always validate the tokens incoming from Application A. This is done by *validating the signature* and by *validating the payload*.

==== Validate the Signature
Validating the signature guarantees the integrity of the token. If the signature validation succeeds the receiving API can be sure that the token has not been changed.

There are two different approaches to validating the signature.

==== Offline using JWKs and the token signature
https://jwt.io[jwt.io] maintains a curated list of libraries for various languages and frameworks which provide convenient functions to interact with oAuth2/OIDC IDPs and also implement the validation of signatures.

Access Tokens issued by PingFederate are signed with a JWK that is accessible from this URL.

.JWKS (JSON Web Key Sets) for the Signature Verification of Access Tokens
----
https://wam.roche.com/pf/JWKS 
----

NOTE: When PingFed was introduced at pRED at the beginning of the OneD program we had to introduce the validation endpoint https://wam.roche.com/ext/OneD/JWT which is different from the default endpoint https://wam.roche.com/pf/JWKS. This was due to some limitations in an earlier PingFed version. While this was and is working fine for integrating pRED applications and APIs amongst each other, it fell short when we needed to integrate with other non-pRED applications which is important in the context of R&D Excellence.
Since April 2025 a solution to this problem is available. pRED tokens can now be validated against https://wam.roche.com/pf/JWKS. 
With this pRED tokens can also be sent to systems outside pRED. But if systems outside pRED should consume a pRED API, then the API owner needs to change the JWKS URL in Gravitee to https://wam.roche.com/pf/JWKS. 
Since https://wam.roche.com/ext/OneD/JWT should be decommissioned at some point this change will be eventually needed for each API but can be gradually implemented.


.Python Token Signature Validation Example (Using pyjwt with the )
[source,python]
----
# Install pyjwt with crypto extension
$ pip install pyjwt[crypto]

# validate.py
import jwt
from jwt import PyJWKClient

token = "<ACCESS TOKEN>"
kid = "fedcert"
jwks_url = "https://wam.roche.com/pf/JWKS"
jwks_client = PyJWKClient(jwks_url)
signing_key = jwks_client.get_signing_key_from_jwt(token)

data = jwt.decode(
    token,
    signing_key.key,
    algorithms=["RS256"],
    options={
        "verify_exp": True,
        "verify_aud": False
        },
)
----

==== Online using Ping Federate APIs
The offline validation has the huge benefit of performance. No API call is required to the IDP and no risk of overloading the IDP APIs exists However, sometimes it can be a simple alternative to just let PingFederate do the validation. One way to do this is to send the Access Token to the `userinfo` endpoint which, on successful validation, returns the payload of the `ID Token`

.Example Request to the Userinfo Endpoint
----
GET /idp/userinfo.openid HTTP/1.1
Host: wam.roche.com
Authorization: Bearer <ACCESS TOKEN>
----

If the token is valid this API will return `HTTP Status 200` and a JSON object with the payload of the `ID Token`. If the token is invalid, the reponse will be `HTTP Status 401`.

==== Validate the Payload
Once the token signature is validated, only a few final checks are required. First the payload needs to be decoded. Again, great instructions as well as libraries to do this are available on https://jwt.io/[jwt.io].

IMPORTANT: The `exp` claim must always be validated

Which claims need to be validated mostly depends on the API and the Authorization Strategy there. Usually what is needed is either the presence of a user id, stored in the `sub` claim or the Email stored in the `email` claim.

NOTE: If the API will not do any authorization based on a users identity, checking the `email` or `sub` claim can be omitted.

=== Exchange of an Access Token

There might be cases when a token created for one client needs to be exchanged to a token for another client. One example is that when a user logs on to the pRED Cockpit application and gets a token with client_id "pred-cockpit". A widget (e.g. from ESAAC) in the Cockpit however uses another client_id when communicating with some APIs. In that case the widget needs to exchange the pred-cockpit token into one with client_id "esaac-soda" as shown below. 
While there could be different ways how to do that, the best option without additional implementation effort is to provide an API endpoint on Gravitee that exchanges the "pred-cockpit" token for an "esaac-soda" token. This API needs to be owned by the "esaac-soda" team as the clientSecret of the "esaac-soda" PingFed client is used for the token exchange. The token exchange can be simply achieved by adding an "HttpCallout" policy and no code is needed in the backend.
Similarly, other token exchange API endpoints from other applications would be needed in case their widgets have the same requirements.
Exchanging the token directly from the front-end is NOT recommended as otherwise the clientSecret would be exposed.

:figure-caption!:
image::Token-exchange.png[title="Illustration of a token exchange"]

IMPORTANT: As a prerequisite the target client needs to be configured for token exchange by the PingFed team. It also requires that the source and target token share the same token structure. Clients that should be used for token exchange need to be secured by a client_secret.  

IMPORTANT: When you create the ticket for the PingFed team (see xref:knowledge_base:it_security_authentication.adoc#_client_onboarding[Client Onboarding,window=_blank]), please add the comment "*activate the Token exchange grant at the oauth client and assign the processor policy PRED-TP-Policy to it*" (see also https://docs.google.com/document/d/1sL1gB4k-UkGdPvzag50LVRRFBV3Rw9AFBCOI4YdJHBg/edit[Pingfederate pRED Token Exchange]).

The below request turns a source token into a target token:
[source,sh]
----
curl -X POST https://wam.roche.com/as/token.oauth2 \
     -H "Content-Type: application/x-www-form-urlencoded" \
     -H "Authorization: BASIC <base 64-encoding of clientID:clientSecret of the target client>" \     
     -d "grant_type=urn:ietf:params:oauth:grant-type:token-exchange" \
     -d "subject_token=SOURCE_ACCESS_TOKEN" \
     -d "resource=https://predtokenexchange" \
     -d "subject_token_type=urn:ietf:params:oauth:token-type:jwt" \
     -d "scope=profile openid" \
----
The response is:
[source,json]
----
{
    "access_token": "eyJh...",
    "issued_token_type": "urn:ietf:params:oauth:token-type:access_token",
    "token_type": "Bearer",
    "expires_in": 7199
}
----

This link:{attachmentsdir}/pRED_Token_exchange.postman_collection.json[Postman Environment] needs to be configured by adding the clientId and clientSecret of the new client (esaac-soda in the previous example).

Token exchange has been implemented e.g. for DELTNICE. See https://delt.pages.roche.com/delt-nice-onedoc/DEVELOPMENT/auth-pingfed.html[here] for further documentation.

== Coding examples
- Python sample code for https://code.roche.com/pred-arch/iam/-/blob/main/oAuth2-AuthCodeGrant.py[Authorization Code Grant Type^]
- AngularJS Typescript Sample Project https://code.roche.com/pred-arch/iam-examples/ng-ping[implementing Authorization Code Grant Type with PKCE and calling the Arvados API^]
- Python code for https://code.roche.com/pred-arch/device-auth-cli/-/blob/main/main.py[Device Auth Grant^] 
- Python code written by the CADD team to connect to https://code.roche.com/cadd/d360_utilities/-/blob/master/d360_get_query.py[D360 API]
- Python code written by PMDA https://code.roche.com/PMDA/pred-bioinformatics/spatialomics/qc/streamlit-ui/-/blob/main/src/auth/oauth.py?ref_type=heads[Streamlit and PingFed^]

- See also the developer guides in the appendix.

== API consumption and authentication for data scientists

Data scientists need to call various APIs and are often struggling with authentication when it comes to APIs protected by PingFederate. 
There is a new endpoint (/v2.1/users/accesstoken) of the https://api.core.minerva.roche.com/catalog/api/0c6353d6-8cac-4e32-a353-d68cacce3235/doc?page=7b613c97-9890-4121-a13c-979890c12145[pREDiLogin API] that allows users to generate a PingFed token with the client_id "pred-generic". 
This simplifies the process for data scientists to access APIs in their scripts and avoids the need to request their own PingFed client or to fetch a token from the browser. 
It's important to note that this functionality is **not intended for applications** which still must use their own dedicated PingFed client.

A Gravitee application connected with the client_id "pred-generic" exists and subscribed several PingFed protected APIs which can be called with a corresponding jwt access token. If you want to check whether an API can be called with a "pred-generic" token, you can simply test it or ask the API owner.

It is important to know that you still need your own https://gravitee.pages.roche.com/documentation/gravitee/API%20consumer/010_introduction.html[Gravitee application] in order to subscribe to other APIs protected by an API-key which is also the case for calling the pREDiLogin API.
Please be also aware that you are not directly subscribed to the above listed APIs and won’t be informed by the API owners about any (e.g. breaking) changes. You can mitigate this by adding a dummy client_id to your Gravitee application and then subscribe to the API. The API owners are then aware of your subscription although no traffic can be observed related to your dummy client_id.

To API owners: 
While this approach aims to benefit data scientists, it reduces visibility into individual API consumers. The aforementioned workaround using a dummy client_id can help to keep the overview. 
If a user asks you to get access to your API with the client_id “pred-generic”, please reach out to christian.blumenroehr@roche.com or moritz.gilsdorf@roche.com. Please be aware that such a subscription assumes that authorization based on the user’s identity in the jwt token is implemented in your API.
And of course in case your API is not yet on Gravitee, please https://gravitee.pages.roche.com/documentation/gravitee/API%20publisher/010_introduction.html[publish] it.


== Appendix

=== Resources from GIS

[cols="2,8",options="header"]
|===

| Link
| Description

| https://docs.google.com/presentation/d/1sSfT4xbOlP6nmaSreFVBZxoHTJeDLBuS87Fx12QDkQY/edit#slide=id.g89857fe113_0_0[Roche IAM Services and Reference Architectures^]
| GIS - Final proposal  -Core working group members: Jing Zhang-Lee (Enterprise Architect for IAM), Carl Koster (Enterprise Architect for Security), Sini Sam Mathew (Integrated Service Owner for IAM), Gary Rowe (TechVision Research, Founder and Principal Analyst), and Doug Simmons (TechVision Research, Principal Analyst for IAM)
Contributors:  IS leadership team, GIS IS secure access engineering teams, secure access services teams, enterprise architecture team and more

| https://docs.google.com/document/d/1BGVA_HqhaadnqApoCGmfvZ2zhRDsr6ubNjzbM3B30B8/edit[IAM Developer Guide for EDIS / PHC^]
| As title says

| https://docs.google.com/document/d/1B7OLRy5HqacrkEWnrdzeL1QLWVzHMli3zAOsvR5yo04/edit[Developer Guide for OAuth Integration^]
| As title says

| https://drive.google.com/drive/folders/1KPCZfnHe3OoTIcOTatF-i4Ur8x3caP9c[Related documents^]
| Folder on shared gDrive

|===

=== Other resources

[cols="2,8",options="header"]
|===

| Link
| Description

| https://docs.google.com/presentation/d/13453AlotJXCX_zMFmTMEc5pEGWvgyCMIPTqS6C95sx0/edit#slide=id.SLIDES_API1428684673_22[pRED IAM Guidelines]
| Slidedeck describing the oAuth2/OIDC standard defined for EDIS adapted to the pRED and OneD needs.

Includes onboarding instructions

| https://code.roche.com/dev-coe/java/oauth2/roche-oauth2-spring[Implementation Example - oAuth2 and OpenID with Spring Framework]
| Example Implementation of OpenID on top of oAuth2 using Roche PingFederate.

| https://docs.pingidentity.com/pingoneaic/latest/am-oauth2/oauth2-implementing-flows.html[Documentation] from PingIdentity - vendor of PingFederate
| Includes specific examples for different OAuth 2.0 grant flows.
|===
